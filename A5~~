#lang typed/racket

(require typed/rackunit)

;--------------------------------------------------------------------------
(struct FunDefC ([params : (Listof Symbol)] [body : ExprC]) #:transparent)

(define-type ExprC (U Value FunDefC AppC LeqC Symbol))

(define-type Env (Listof Binding))
(define-type Value (U Real Boolean String CloV PrimV LamC))
;(define-type Boolean
;  [bind () (name : #f)])

(struct Binding ([name : Symbol] [val : Value]))


(struct AppC ([id : ExprC] [args : (Listof ExprC)]) #:transparent)
(struct LeqC ([test : ExprC] [then : ExprC] [rest : ExprC]) #:transparent)
(struct CloV ([params : (Listof Symbol)] [body : ExprC] [env : Env]) #:transparent)
(struct PrimV ([func : ((Listof Value) -> Value)]))
(struct LamC ([arg : Symbol] [body : ExprC]) #:transparent)

 
;---------------------------------------------------------------------------

;Checks if a given argument is a binop
(: is-binop? (Any -> Boolean : #:+ Symbol))
(define (is-binop? sym)
  (and (symbol? sym) (hash-has-key? ht sym))) 

;Checks if a given argument is a keyword
(: not-keyword? (Any -> Boolean : #:+ Symbol))
(define (not-keyword? sym)
  (and (symbol? sym) (not (hash-has-key? ht sym)) (not (or (eq? 'ifleq0? sym) (eq? 'func sym) (eq? ': sym)))))

;---------------------------------------------------------------------------

(define (add [args : (Listof Value)]) : Real
  (match args
    [(list (? real? op1) (? real? op2)) (+ op1 op2)]
    [other (error 'add "OAZO Input invalid")]))

(define (sub [args : (Listof Value)]) : Real
  (match args
    [(list (? real? op1) (? real? op2)) (- op1 op2)]
    [other (error 'sub "OAZO Input invalid")]))

(define (mult [args : (Listof Value)]) : Real
  (match args
    [(list (? real? op1) (? real? op2)) (* op1 op2)]
    [other (error 'mult "OAZO Input invalid")]))

(define (div [args : (Listof Value)]) : Real
  (match args
    [(list (? real? op1) 0) (error " OAZO: Divisor cannot be 0")]
    [(list (? real? op1) (? real? op2)) (/ op1 op2)]
    [other (error 'div "OAZO Input invalid")]))

(define (less-than [args : (Listof Value)]) : Boolean
  (match args
    [(list (? real? op1) (? real? op2)) (<= op1 op2)]
    [other (error 'less-than "OAZO Input invalid")]))

(define (serialize  [args : (Listof Value)]) : String
  (match args
    [(list (? real? r)) (~v r)]
    [(list #t) "true"]
    [(list #f) "false"]
    [(list CloV) "#<procedure>"]
    [(list PrimV) "#<primop>"]
    [other (error 'serialize "OAZO too many args")]))

(define (err [args : (Listof Value)])
  (error 'user-error (serialize args)))

(define ht (hash '+ add '- sub '* mult '/ div 'equal? equal?))
(define baseEnv (list
                 (Binding '+ (PrimV add))
                 (Binding '- (PrimV sub))
                 (Binding '* (PrimV mult))
                 (Binding 'true #t)
                 (Binding 'false #f)))


;---------------------------------------------------------------------------

;Parses an Sexpression into an ExprC
(define (parse [s : Sexp]) : ExprC
  (match s
    [(? real? r) r]
    [(? string? s) s]
    [(? boolean? b) b]
    [(list 'anon (list (? not-keyword? ids) ...) ': expr) (FunDefC (cast ids (Listof Symbol)) (parse expr))]
    [(list (? not-keyword? id) exps ...) (AppC id (map parse exps))]
    [(list 'ifleq0? test then rest) (LeqC (parse test) (parse then) (parse rest))]
    [(? not-keyword? s) s]
    [other (error "OAZO Malformed ExprC:" s)]))


;Parses a Sexp into a FunDefC
;(define (parse-fundef [s : Sexp]) : FunDefC
;  (match s
;    [(list 'anon (list (? not-keyword? ids) ...) ': expr)
;     (FunDefC (cast ids (Listof Symbol)) (parse expr))])) 

;Parse the entire program 
;(define (parse-prog [s : Sexp]) : (Listof FunDefC)
;  (match s
;    ['() '()]
;    [(cons f r) (cons (parse-fundef f) (parse-prog r))]
;   [other (error "OAZO Malformed Program:" s)]))

;---------------------------------------------------------------------------

;Looksup a value in an environment
(define (lookup [for : Symbol] [env : Env]) : Value
  (match env
    ['() (error 'lookup "name not found: ~e" for)]
    [(cons (Binding name val) r) (cond
                                   [(symbol=? for name) val]
                                   [else (lookup for r)])]))

;Gets a Var from a list with name n
;(define (get-var [n : Symbol] [env : (Listof var)]) : var
;  (cond
;    [(empty? env) (error 'get-var "OAZO reference to undefined Binding")]
;    [(cons? env)
;     (cond
;       [(equal? n (var-name (first env))) (first env)] 
;       [else (get-var n (rest env))])]))

;-------------------------------------------------------------------------

;Extends the given environment
(define (extend [env : Env] [values : (Listof Value)] [names : (Listof Symbol)]) : Env
  (match values
    ['() env]
    [(cons f r) (cons (Binding (first names) f) (extend env r (rest names)))]))


;Interprets an AST (as an ExprC) into a real number
(define (interp [e : ExprC] [env : Env]) : Value
  (match e
    [(? real? r) r]
    [(FunDefC params body) (CloV params body env)]
    [(AppC id Listexp)
     (match (interp id env)
       [(CloV params body env)
        (define arglist (map (lambda ([expr : ExprC]) (interp expr env)) Listexp))
        (define env2 (extend env arglist params))
        (interp body env2)]
       [(PrimV func) (func (map (lambda ([expr : ExprC]) (interp expr env)) Listexp))]
       [other (error 'interp "OAZO not a function")])]
;    [(LeqC test then rest) (cond
;                            [(<= (interp test fds env) 0) (interp then fds env)]
;                           [else (interp rest fds env)])]
    ;[(? symbol? s) (var-value (get-var s env))]
    [(? symbol? s) (lookup s env)]))


(check-equal? (interp 'x (list (Binding 'x 4))) 4)

;Find the main function and interp it
(define (interp-fns [l : (Listof FunDefC)]) : Value
  (interp (AppC 'main '()) baseEnv))


;Wrapper for our praser and interpretor 
;(: top-interp (Sexp -> String))
;(define (top-interp fun-sexps)
;  (serialize (list (interp-fns (parse-prog fun-sexps)))))

(define (top-interp [s : Sexp]) : String
  (serialize (list (interp (parse s) baseEnv))))

(check-equal? (interp (add '(1 2)) '()) 3)

;program does not use parse-fundef nor parse-prog
;var renamed as Binding to match the book
;took out fds as a parameter in interp
;changed top-interp to one in specs
;added true and false literal bindings to base env
;added definition of LamC
 


;-------------------------------------------------------------------------

;is-binop?
(check-equal? (is-binop? '*) #t)
(check-equal? (is-binop? 'f) #f)

;not-keyword?
(check-equal? (not-keyword? '*) #f)
(check-equal? (not-keyword? '+) #f)
(check-equal? (not-keyword? 'abc) #t)

;parse
(check-equal? (parse '{ifleq0? x {fun 7} 8}) (LeqC 'x (AppC 'fun '(7)) 8))
(check-exn (regexp (regexp-quote "OAZO Malformed ExprC: '(4 4)"))
           (lambda () (parse '{4 4})))
(check-exn (regexp (regexp-quote "OAZO Malformed ExprC: '(+ / 3)"))
           (lambda () (parse '{+ / 3})))

;parse-fundef
;(check-exn (regexp (regexp-quote "OAZO Malformed function structure"))
;           (lambda () (parse-fundef '{4})))
;(check-exn (regexp (regexp-quote "match: no matching clause for '(func (+ 4) : 13)"))
;           (lambda () (parse-fundef '{func {+ 4} : 13})))


;interp
;(check-equal? (interp (LeqC -1 2 5) '() '()) 2)
;(check-equal? (interp (LeqC 3 7 8) '() '()) 8)
(check-exn (regexp (regexp-quote "lookup: name not found: 'x"))
           (lambda () (interp 'x '())))


;

;top-interp
;(define prog '{
;               {func {fib x} : {ifleq0? {- x 1} 1 {+ {fib {- x 1}} {fib {- x 2}}}}}
;               {func {main init} : {fib 4}}
;               })

(define prog2 ' {
                 {func {sqr x} : {* x x}}
                 {func {main init} : {sqr 7}}
                 })
(define prog3 '{
                {func {f x x} : x}
                {func {main} : {f x}}
                })

;(define prog4 '{
 ;               {anon {five} : 5}
              ;  {anon {main} : {five}} 
  ;              })
(define prog4 '{anon {five} : 5})

(define prog5 '{
                {func {f x} : (+ x 2)}
                {func {main} : {f 3 4 5}}
                })
(check-exn (regexp (regexp-quote "OAZO Malformed ExprC: '((func (f x x) : x) (func (main) : (f x)))"))
           (lambda () (top-interp prog3)))



;round
;(define round '{anon {round x} : {ifleq0? {add '(x 0.499999)} 0 {+ 1 {round {- x 1}}}}})
;(define round-top '{anon {round-top x} : {ifleq0? x {- 0 {round {- 0 x}}} {round x}}})
;(check-equal? (top-interp (list round round-top '{anon {main init} : {round-top 7.5}})) 8)
;(check-equal? (top-interp (list round round-top '{anon {main init} : {round-top -7.4}})) -7)

;(check-equal? (top-interp prog) 5)
;(check-equal? (top-interp prog2) 49)
;(check-equal? (interp-fns
;               (parse-prog '{{func {f x} : {+ x 14}}
;                             {func {main init} : {f 2}}}))
;              16)

;testing for multiple parameters
(check-exn (regexp (regexp-quote "OAZO Malformed ExprC: '((func (f x x) : x) (func (main) : (f x)))"))
           (lambda () (top-interp prog3)))



;Testing for zero parameters
(check-equal? (top-interp prog4) 5) 
