#lang typed/racket

(require typed/rackunit)

;--------------------------------------------------------------------------
(struct FunDefC ([params : (Listof Symbol)] [body : ExprC]) #:transparent)

(define-type ExprC (U Value FunDefC AppC IfC Symbol))

(define-type Env (Listof Binding))
(define-type Value (U Real Boolean String CloV PrimV LamC))

(struct Binding ([name : Symbol] [val : Value]))

(struct AppC ([id : ExprC] [args : (Listof ExprC)]) #:transparent)
(struct IfC ([if : ExprC] [then : ExprC] [else : ExprC]) #:transparent)
(struct CloV ([params : (Listof Symbol)] [body : ExprC] [env : Env]) #:transparent)
(struct PrimV ([func : ((Listof Value) -> Value)]))
(struct LamC ([arg : Symbol] [body : ExprC]) #:transparent)

 
;---------------------------------------------------------------------------

;Checks if a given argument is a keyword
(: not-keyword? (Any -> Boolean : #:+ Symbol))
(define (not-keyword? sym)
  (and (symbol? sym) (not (or (eq? 'if sym) (eq? 'let sym) (eq? 'anon sym) (eq? ': sym) (eq? '<- sym)))))

;---------------------------------------------------------------------------

;Adds two reals
(define (add [args : (Listof Value)]) : Real
  (match args
    [(list (? real? op1) (? real? op2)) (+ op1 op2)]
    [other (error 'add "OAZO Input invalid")]))

;Subtract two reals
(define (sub [args : (Listof Value)]) : Real
  (match args
    [(list (? real? op1) (? real? op2)) (- op1 op2)]
    [other (error 'sub "OAZO Input invalid")]))

;Multiply two reals
(define (mult [args : (Listof Value)]) : Real
  (match args
    [(list (? real? op1) (? real? op2)) (* op1 op2)]
    [other (error 'mult "OAZO Input invalid")]))

;Divide two reals
(define (div [args : (Listof Value)]) : Real
  (match args
    [(list (? real? op1) 0) (error "OAZO Divisor cannot be 0")]
    [(list (? real? op1) (? real? op2)) (/ op1 op2)]
    [other (error 'div "OAZO Input invalid")]))

;Compares two reals
(define (less-than [args : (Listof Value)]) : Boolean
  (match args
    [(list (? real? op1) (? real? op2)) (<= op1 op2)]
    [other (error 'less-than "OAZO Input invalid")]))

;Serialized a value
(define (serialize  [args : (Listof Value)]) : String
  (match args
    [(list (? real? r)) (~v r)]
    [(list #t) "true"]
    [(list #f) "false"]
    [(list (? CloV? v)) "#<procedure>"]
    [(list (? PrimV? v)) "#<primop>"]
    [other (error 'serialize "OAZO too many args")]))

;Signals an error
(define (err [args : (Listof Value)])
  (error 'user-error (serialize args)))


(define baseEnv (list
                 (Binding '+ (PrimV add))
                 (Binding '- (PrimV sub))
                 (Binding '* (PrimV mult))
                 (Binding '/ (PrimV div))
                 (Binding '<= (PrimV less-than))
                 (Binding 'erorr (PrimV err))
                 (Binding 'true #t)
                 (Binding 'false #f)))

;---------------------------------------------------------------------------

;Parses an Sexpression into an ExprC
(define (parse [s : Sexp]) : ExprC
  (match s
    [(? real? r) r]
    [(? string? s) s]
    [(list 'anon (list (? not-keyword? ids) ...) ': expr) (FunDefC (cast ids (Listof Symbol)) (parse expr))]
    [(list 'if ifExpr 'then thenExpr 'else elseExpr) (IfC (parse ifExpr) (parse thenExpr) (parse elseExpr))]
    [(list expr exps ...) (AppC (parse expr) (map parse exps))]
    [(? not-keyword? s) s]
    [other (error "OAZO Malformed ExprC:" s)]))



;---------------------------------------------------------------------------

;Looksup a value in an environment
(define (lookup [for : Symbol] [env : Env]) : Value
  (match env
    ['() (error 'lookup "name not found: ~e" for)]
    [(cons (Binding name val) r) (cond
                                   [(symbol=? for name) val]
                                   [else (lookup for r)])]))

;-------------------------------------------------------------------------

;Extends the given environment
(define (extend [env : Env] [values : (Listof Value)] [names : (Listof Symbol)]) : Env
  (match values
    ['() env]
    [(cons f r) (cons (Binding (first names) f) (extend env r (rest names)))]))


;Interprets an AST (as an ExprC) into a real number
(define (interp [e : ExprC] [env : Env]) : Value
  (match e
    [(? real? r) r]
    [(FunDefC params body) (CloV params body env)]
    [(AppC id Listexp)
     (match (interp id env)
       [(CloV params body env)
        (define arglist (map (lambda ([expr : ExprC]) (interp expr env)) Listexp))
        (define env2 (extend env arglist params))
        (interp body env2)]
       [(PrimV func) (func (map (lambda ([expr : ExprC]) (interp expr env)) Listexp))]
       [other (error 'interp "OAZO not a function")])]
    [(? symbol? s) (lookup s env)]
    [(? PrimV? v) v] ;Pass up
    [(? CloV? v) v])) ;Pass up

;Wrapper for our praser and interpretor 
(define (top-interp [s : Sexp]) : String
  (serialize (list (interp (parse s) baseEnv))))

;program does not use parse-fundef nor parse-prog
;var renamed as Binding to match the book
;took out fds as a parameter in interp
;changed top-interp to one in specs
;added true and false literal bindings to base env
;added definition of LamC


;fixed AppC parsing to not use function names
;Added PrimV and CloV passup to interp
;Added all needed test-cases
;Added parsing for if statements

;-------------------------------------------------------------------------


;not-keyword?
(check-equal? (not-keyword? ':) #f)
(check-equal? (not-keyword? '<-) #f)
(check-equal? (not-keyword? 'abc) #t)

;parse
(check-equal? (parse '{if true then 1 else 2}) (IfC 'true 1 2))
(check-equal? (parse "hello") "hello")


;interp
(check-equal? (interp (AppC (PrimV add) '(4 5)) '()) 9)
(check-equal? (interp (AppC (CloV '(x y) 'x '()) '(4 5)) '()) 4)
(check-exn (regexp (regexp-quote "OAZO not a function"))
           (lambda () (interp (AppC 4 '(4)) '())))

(check-equal? (interp 'x (list (Binding 'y 5) (Binding 'x 4))) 4) 

(check-equal? (interp (add '(1 2)) '()) 3)

(check-exn (regexp (regexp-quote "lookup: name not found: 'x"))
           (lambda () (interp 'x '())))


;Prim Functions

(check-equal? (sub '(4 5)) -1)
(check-equal? (mult '(4 5)) 20)
(check-equal? (div '(5 5)) 1)
(check-equal? (less-than '(3 4)) #t)

(check-equal? (serialize '(#t))"true")
(check-equal? (serialize '(#f))"false")
(check-equal? (serialize (list (CloV '() 1 '()))) "#<procedure>")
(check-equal? (serialize (list (PrimV add))) "#<primop>")

(check-exn (regexp (regexp-quote "user-error: 5"))
           (lambda () (err (list  5))))

(check-exn (regexp (regexp-quote "OAZO Input invalid"))
           (lambda () (add (list "s" 5))))

(check-exn (regexp (regexp-quote "OAZO Input invalid"))
           (lambda () (sub (list #f 5))))

(check-exn (regexp (regexp-quote "OAZO Input invalid"))
           (lambda () (mult (list #t 5))))

(check-exn (regexp (regexp-quote "OAZO Input invalid"))
           (lambda () (div (list "7" 5))))
(check-exn (regexp (regexp-quote "OAZO Divisor cannot be 0"))
           (lambda () (div (list 5 0))))

(check-exn (regexp (regexp-quote "OAZO Input invalid"))
           (lambda () (less-than (list 3 4 5))))

(check-exn (regexp (regexp-quote "OAZO too many args"))
           (lambda () (serialize (list "s" 5))))


;top-interp
(define prog2 ' {
                 {func {sqr x} : {* x x}}
                 {func {main init} : {sqr 7}}
                 })
(define prog3 '{
                {func {f x x} : x}
                {func {main} : {f x}}
                })

(define prog4 '{{anon {five} : 5} 3})

(check-exn (regexp (regexp-quote "OAZO Malformed ExprC"))
           (lambda () (top-interp prog3)))


;testing for multiple parameters
(check-exn (regexp (regexp-quote "OAZO Malformed ExprC"))
           (lambda () (top-interp prog3))) 



;Testing for zero parameters
(check-equal? (top-interp prog4) "5")  
